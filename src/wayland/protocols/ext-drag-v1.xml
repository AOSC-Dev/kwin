<?xml version="1.0" encoding="UTF-8"?>
<protocol name="ext_drag_v1">

  <copyright>
    Copyright 2020 The Chromium Authors.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice (including the next
    paragraph) shall be included in all copies or substantial portions of the
    Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
  </copyright>

  <interface name="zcr_extended_drag_v1" version="1">
    <description summary="Extensions for the core DND protocol.">
      This protocol extends the Wayland drag-and-drop with features not
      supported by the core protocol, such as, making toplevel shell surfaces
      "draggable", as well as making them "snappable" into and out of other
      surfaces as they are dragged around.

      A common use case for this is a Chromium-like tab/window dragging UX,
      where the user is able to drag a tab (or any other kind of UI piece) out
      of its original window, into a new surface anchored to the pointer cursor,
      similar to a regular drag icon but with enhanced and more configurable
      capabilities.

      ## Typical usage of this protocol:

      1. An UI item (eg: a tab in a tab bar) starts to be dragged within shell
      surface A owned by source client S. At some point, it gets far enough
      from its original location and S then starts a Wayland "extended drag"
      session, which protocol-wise requires to:

      1.1. Create a wl_data_source, set one (or more) mime type and the
      supported dnd actions;

      1.2. Create a zcr_extended_drag_source for the newly created drag source. Here it
      is possible to set a few options, such as:
        - ALLOW_SWALLOW: determines that the dragged item can be attached (or
        incorporated, also referred to as "swallow" in this protocol) to
        another surface, including use cases such as Chrome's tab drag.
        - ALLOW_DROP_NO_TARGET: In the standard DND protocol, dropping
        something outside shell surfaces lead to a wl_data_source::cancel,
        which is problematic in use cases such as tab drag, preventing us from
        detecting when it was really cancelled, e.g: ESC pressed.
        - LOCK_CURSOR: Keep the cursor shape unchanged during the whole
        session. Ultimately, having an extended drag source attached to the
        wl_data_source used to wl_data_device::start_drag instructs the
        compositor to run the drag session in the "extended mode".

      1.3 Start the drag session as usual (i.e: wl_data_source::start_drag),
      with a null drag icon surface. Assuming that we're still in attached
      mode for now. In addition, from now on, client S must start watching for
      wl_data_device::{enter,leave,motion} events in order to be able to
      detect the next actions and state transitions as the user drags the UI
      item around.

      1.4 Store the (x_offset, y_offset) location where the drag started in S
      and keep them synced to the values received in wl_data_device::motion()
      events.

      2. Once the drag gets far enough from the original UI item's container
      (ie: tab bar), it's time to detach (or unswallow) it from surface A. To
      achieve it, client S must:

      2.1. Create a new wl_surface B + its corresponding shell surface, e.g: a
      toplevel xdg surface where a new detached browser window will rendered
      to in Chrome's tab drag use case;

      2.2. Issue a zcr_extended_drag_source::drag(B, x_offset, y_offset) request, which
      tells the compositor (in advance) that B must be set as the drag surface,
      using x and y offsets to translate it from the current pointer location;

      2.3. Map surface B (configure, attach buffer, etc) as usual. After this
      B's shell surface should show up tied to the mouse pointer and the
      compositor is supposed to take care of it, putting it in a special state
      where, for example, it does not receive events, etc, acting just like a
      standard DND "drag icon". At this point, the "unswallow" operation is
      done and the drag session enters in detached state.

      3. Supposing the drop happens while in detached state, there are 2
      possible flows, which depend on whether ALLOW_DROP_NO_TARGET config is
      set or not (see 1.2). If it is set, wl_data_source::dnd_finished event
      is sent to the source client S, otherwise wl_data_source::cancelled is
      sent.

      4. Otherwise, if before dropping, the pointer enters surface C, owned by
      client T. T receives a wl_data_offer O through wl_data_device::offer
      event as usual, to which it can attach a zcr_extended_drag_offer XO to it by
      issuing zcr_extended_drag::get_extended_drag_offer(O). Target client T, then
      starts monitoring wl_data_device::motion events, so that it can trigger
      a swallow based on where the pointer is. If B is dragged over a region
      that leads to a swallow, T must:

      4.1 Issue a zcr_extended_drag_offer::swallow(serial, mime) request, asking source
      client S to incorporate the dragged item into its UI. S then receives a
      zcr_extended_drag_source::swallow(mime) event and it can accept it by calling
      zcr_extended_drag_source::drag(null, 0, 0), so client T can finally render it as
      part of its UI. At this point, the session is back to a state similar to
      1.4. So, similarly to 2, once the drag gets far enough, T might want to
      unswallow (aka: detach) the UI item. In order to do so it must:

      4.1.1 Call unswallow(serial, mime, x_offset, y_offset) on the drag offer
      XO (created at step 4), whereas the offsets tell how the dragged surface
      must be positioned related to the pointer location. Client S will then
      receive a zcr_extended_drag_source::unswallow(mime, x_offset, y_offset) event so
      that it can create and map a new surface D and issue a
      zcr_extended_drag_source::drag(D, x_offset, y_offset), same as in step 2.3,
      making surface D to show up under the pointer. At target side, T can then
      re-render its UI without the dragged item. This finishes the unswallow
      (or detaching) operation, transitioning the session back to "detached"
      state.

      Warning! The protocol described in this file is experimental and
      backward incompatible changes may be made. Backward compatible changes
      may be added together with the corresponding uinterface version bump.
      Backward incompatible changes are done by bumping the version number in
      the protocol and uinterface names and resetting the interface version.
      Once the protocol is to be declared stable, the 'z' prefix and the
      version number in the protocol and interface names are removed and the
      interface version number is reset.
    </description>

    <enum name="options" bitfield="true">
      <description summary="extended drag configuration flags.">
        Bitmask flags that can be used to configure how the drag session will
        operate. By default no additional option is set.

        Source client might set allow_swallow option to tell the compositor
        that the dragged UI item can be snapped out and into other surfaces
        (swallowed/unswallowed), eg: Chromium's tab dragging UX.

        allow_drop_no_target controls how source and destination clients are
        notified when the drop happens, if it is set the DnD operation is
        considered successfully finished regardless the drop location (eg:
        outside any shell surface or there is no target that can accept it).

        lock_cursor might be used to keep the cursor shape locked during the
        extended drag session, regardless current the mime types, dnd action
        negotiation status.
      </description>
      <entry name="default" value="0"/>
      <entry name="allow_swallow" value="1"/>
      <entry name="allow_drop_no_target" value="2"/>
      <entry name="lock_cursor" value="4"/>
    </enum>

    <request name="get_extended_drag_source">
      <description summary="get an extended_drag_source for a wl_data_source">
        Create an extended drag source object. See zcr_extended_drag_source_v1
        interface for details.
      </description>
      <arg name="id" type="new_id" interface="zcr_extended_drag_source_v1"/>
      <arg name="data_source" type="object" interface="wl_data_source"/>
      <arg name="options" type="uint" enum="zcr_extended_drag_v1.options"/>
    </request>

    <request name="get_extended_drag_offer">
      <description summary="get an extended_drag_offer for a wl_data_offer">
        Create an extended drag offer object. See zcr_extended_drag_offer_v1 interface
        for details.
      </description>
      <arg name="id" type="new_id" interface="zcr_extended_drag_offer_v1"/>
      <arg name="data_offer" type="object" interface="wl_data_offer"/>
    </request>
  </interface>

  <interface name="zcr_extended_drag_source_v1" version="1">
    <description summary="extensions for the standard drag data source">
      The zcr_extended_drag_source_v1 interface extends the wl_data_source with
      features unsupported by the standard drag-and-drop protocol.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the extended drag source object"/>
    </request>

    <request name="drag">
      <description summary="Update the dragged surface">
        Update the dragged surface. If null is passed, the dragged surface gets
        unset, making it to not being moved anymore under the pointer cursor.
        Otherwise, it will be set as the dragged surface, making it to be
        visually anchored to the pointer cursor. surface is expected to have a
        toplevel shell surface role assigned, which allows it to be dropped
        smoothly into an arbitrary location of the shell, so turning it
        instantly into a regular toplevel window, which is not possible with the
        standard DND protocol.

        x and y offsets are described in surface-local coordinates, with no
        scale applied, that determine how the surface must be positioned
        relative to the cursor location, similar to drag icon offsets in
        standard DND operations.
      </description>
      <arg name="surface" type="object" interface="wl_surface" allow-null="true" summary="drag icon surface"/>
      <arg name="x_offset" type="int" summary="dragged surface x offset"/>
      <arg name="y_offset" type="int" summary="dragged surface y offset"/>
    </request>

    <event name="swallow">
      <description summary="the receiving client requested to swallow the drag.">
        The receiving client has requested to swallow the dragged surface.
        Which, in a drag operation involving 2 or more clients, can be used to
        negotiate when the dragged surface is incorporated (aka: merged) into
        its UI. See zcr_extended_drag_offer_v1::swallow request for more details.
      </description>
      <arg name="mime_type" type="string" summary="mime type to be swallowed by the client"/>
    </event>

    <event name="unswallow">
      <description summary="the receiving client requested to unswallow the drag.">
        The receiving client has requested to unswallow the dragged surface.
        Which, in a drag operation involving more than a single client, can be
        used to negotiate when the dragged surface is snapped out of the
        receiving client's UI.

        X and Y offsets are expressed in surface-local coordinates, with no
        scale applied, and describe how the surface must be positioned relative
        to the cursor location, similar to drag icon offsets in standard DND
        operations. Note that these coordinates are local to the unswallowed
        surface, created and owned by the source client, so it can be used
        rightaway to call drag(surface, x_offset, y_offset) in response to
        receiving client's request.
      </description>
      <arg name="mime_type" type="string" allow-null="true" summary="mime type accepted by the client"/>
      <arg name="x_offset" type="int" summary="dragged surface x offset"/>
      <arg name="y_offset" type="int" summary="dragged surface y offset"/>
    </event>
  </interface>

  <interface name="zcr_extended_drag_offer_v1" version="1">
    <description summary="extensions for the standard drag data offer.">
      The zcr_extended_drag_offer_v1 interface extends the wl_data_offer with features
      unsupported by the standard drag-and-drop protocol.
    </description>

    <request name="destroy" type="destructor">
      <description summary="destroy the extended drag offer object"/>
    </request>

    <request name="swallow">
      <description summary="Requests the drag source to swallow the drag.">
        Requests the drag source to swallow the dragged surface. This means the
        receiving client accepts and will incorporate the dragged surface into
        its UI. For example, a browser tab is dragged and snapped to an icon
        grid.
      </description>
      <arg name="serial" type="uint" summary="serial number of the swallow request"/>
      <arg name="mime_type" type="string" allow-null="true" summary="mime type being swallowed"/>
    </request>

    <request name="unswallow">
      <description summary="Requests the drag source to unswallow the drag.">
        Requests the drag source to unswallow the dragged surface. Which means
        that the receiving client wants to undo a previously swallowed dragged
        surface, i.e: detach it from its UI.

        X and Y offsets are expressed in surface-local coordinates, with no
        scale applied and describe how the surface must be positioned relative
        to the cursor location, similar to drag icon offsets in standard DND
        operations. Note that these coordinates are local to the currently
        focused surface, owned by the receiving client, which may differ from
        corresponding offsets at source side (which owns the unswallowed
        surface), for instance, when the receiving surface is on a wl_output
        with different scale value. Compositor handles such conversion before
        delivering the zcr_extended_drag_source_v1::swallow event counterpart to the
        source client.
      </description>
      <arg name="serial" type="uint" summary="serial number of the unswallow request"/>
      <arg name="mime_type" type="string" summary="mime type being unswallowed"/>
      <arg name="x_offset" type="int" summary="dragged surface x offset"/>
      <arg name="y_offset" type="int" summary="dragged surface y offset"/>
    </request>
  </interface>
</protocol>
